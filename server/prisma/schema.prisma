// Prisma schema â€” first pass for core entities
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String              @id @default(cuid())
  name              String
  email             String              @unique
  role              AppRole             @relation(fields: [roleId], references: [id])
  roleId            String
  department        Department          @relation("DepartmentUsers", fields: [departmentId], references: [id])
  departmentId      String
  // Optional manager for approvals and reporting
  manager           User?               @relation("UserManager", fields: [managerId], references: [id])
  managerId         String?
  reports           User[]              @relation("UserManager")
  // Registration + onboarding extras
  requestedDepartmentId String?
  intendedRoleId    String?
  billable          Boolean             @default(false)
  billRate          Float?
  costRate          Float?
  utilizationTarget Int?
  skills            String[]
  title             String?
  phone             String?
  timeZone          String?
  onboardingCompletedAt DateTime?
  deletedAt         DateTime?
  passwordHash      String?
  emailVerifiedAt   DateTime?
  failedLoginAttempts Int               @default(0)
  lockedUntil       DateTime?
  lastLoginAt       DateTime?
  isActive          Boolean             @default(true)
  memberships       ProjectMembership[]
  timeLogs          TimeLog[]
  comments          Comment[]           @relation("CommentAuthor")
  mentionedIn       Comment[]           @relation("CommentMentions")
  documentsReviewed Document[]          @relation("DocumentReviewer")
  documentsCreated  Document[]          @relation("DocumentCreator")
  notifications     Notification[]      @relation("UserNotifications")
  historyEvents     HistoryEvent[]      @relation("HistoryCreatedBy")
  meetingLogsCreated MeetingLog[]       @relation("MeetingLogCreator")
  calendarAccounts  CalendarAccount[]
  calendarSources   CalendarSource[]
  oauthStates       CalendarOAuthState[]
  calendarEvents    CalendarEvent[]     @relation("CalendarEventOwner")
  calendarEventsCreated CalendarEvent[] @relation("CalendarEventCreator")
  invoicesCreated   Invoice[]           @relation("InvoiceCreatedBy")
  invoicesApproved  Invoice[]           @relation("InvoiceApprovedBy")
  authTokens        AuthToken[]
  approvalRequests  ApprovalRequest[]
  additionalCosts   AdditionalCost[]
  // Back-relations for audits, department leads and approvals
  adminAudits       AdminAudit[]         @relation("AdminAuditAdmin")
  targetAudits      AdminAudit[]         @relation("AdminAuditTarget")
  leads             Department[]         @relation("DepartmentLead")
  decisions         ApprovalRequest[]    @relation("ApprovalDecider")
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([name])
  @@index([email])
  @@index([isActive])
  @@index([roleId, departmentId])
}

enum AuthTokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
  REFRESH
}

model AuthToken {
  id         String        @id @default(cuid())
  user       User          @relation(fields: [userId], references: [id])
  userId     String
  type       AuthTokenType
  tokenHash  String        // sha256 of secret token
  expiresAt  DateTime
  usedAt     DateTime?
  createdAt  DateTime      @default(now())

  @@index([userId, type])
  @@index([tokenHash])
}

// Administrative audit trail
model AdminAudit {
  id             String   @id @default(cuid())
  admin          User     @relation("AdminAuditAdmin", fields: [adminId], references: [id])
  adminId        String
  target         User?    @relation("AdminAuditTarget", fields: [targetUserId], references: [id])
  targetUserId   String?
  action         String
  details        String?
  createdAt      DateTime @default(now())

  @@index([adminId, createdAt])
  @@index([targetUserId, createdAt])
}


enum CalendarProvider {
  GOOGLE
  MICROSOFT
}

enum CalendarSourceType {
  ICS_URL
}

model CalendarAccount {
  id           String           @id @default(cuid())
  user         User             @relation(fields: [userId], references: [id])
  userId       String
  provider     CalendarProvider
  email        String
  accessToken  String
  refreshToken String
  expiresAt    DateTime?
  scope        String?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  @@unique([userId, provider, email])
  @@index([userId, provider, email])
}

model CalendarSource {
  id        String             @id @default(cuid())
  user      User               @relation(fields: [userId], references: [id])
  userId    String
  type      CalendarSourceType
  name      String
  url       String
  color     String?            @default("#10b981")
  enabled   Boolean            @default(true)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@index([userId, type])
}

// Short-lived OAuth state to robustly link connect flow to a user
model CalendarOAuthState {
  id        String           @id @default(cuid())
  user      User             @relation(fields: [userId], references: [id])
  userId    String
  provider  CalendarProvider
  nextPath  String?          @default("/calendar")
  createdAt DateTime         @default(now())
  expiresAt DateTime?

  @@index([userId, provider])
}

enum CalendarEventType {
  TASK
  MEETING
  REMINDER
  PERSONAL
  OUTSOURCED
}

enum CalendarEventPriority {
  HIGH
  MEDIUM
  LOW
}

enum CalendarEventStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum CalendarEventPlatform {
  TEAMS
  ZOOM
  GOOGLE_MEET
  PHYSICAL
}

enum CalendarEventRecurrence {
  DAILY
  WEEKLY
  MONTHLY
}

model CalendarEvent {
  id            String                   @id @default(cuid())
  user          User                     @relation("CalendarEventOwner", fields: [userId], references: [id])
  userId        String
  createdBy     User                     @relation("CalendarEventCreator", fields: [createdById], references: [id])
  createdById   String
  title         String
  description   String?
  type          CalendarEventType        @default(TASK)
  startAt       DateTime
  endAt         DateTime
  priority      CalendarEventPriority    @default(MEDIUM)
  status        CalendarEventStatus      @default(SCHEDULED)
  meetingLink   String?
  platform      CalendarEventPlatform?
  project       String?
  attendees     String[]
  isRecurring   Boolean                  @default(false)
  recurrenceType CalendarEventRecurrence?
  createdAt     DateTime                 @default(now())
  updatedAt     DateTime                 @updatedAt

  @@index([userId, startAt])
  @@index([createdById, createdAt])
}

model Department {
  id        String   @id @default(cuid())
  name      String   @unique
  lead      User?    @relation("DepartmentLead", fields: [leadId], references: [id])
  leadId    String?
  disabled  Boolean  @default(false)
  users     User[]    @relation("DepartmentUsers")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AppRole {
  id        String   @id @default(cuid())
  name      String   @unique
  users     User[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

model ApprovalRequest {
  id          String         @id @default(cuid())
  user        User           @relation(fields: [userId], references: [id])
  userId      String         @unique
  status      ApprovalStatus @default(PENDING)
  requestedDepartmentId String?
  requestedRoleId String?
  referredBy   String?
  managerName  String?
  billable     Boolean       @default(false)
  reason       String?
  decidedBy    User?         @relation("ApprovalDecider", fields: [decidedById], references: [id])
  decidedById  String?
  submittedAt  DateTime      @default(now())
  decidedAt    DateTime?

  @@index([status])
  @@index([requestedDepartmentId])
}

// Simple key-value system settings for runtime configuration
model SystemSetting {
  key       String   @id
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Project {
  id             String              @id @default(cuid())
  code           String              @unique
  title          String
  description    String
  status         ProjectStatus       @default(PLANNING)
  visibility     Visibility          @default(TEAM)
  allocatedHours Int                 @default(0)
  startDate      DateTime?
  endDate        DateTime?
  phases         Phase[]
  memberships    ProjectMembership[]
  meetingLogs    MeetingLog[]
  attachments    Attachment[]
  documents      Document[]
  receipts       PaymentReceipt[]
  additionalCosts AdditionalCost[]
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  invoices       Invoice[]
}

model ProjectMembership {
  id        String      @id @default(cuid())
  project   Project     @relation(fields: [projectId], references: [id])
  projectId String
  user      User        @relation(fields: [userId], references: [id])
  userId    String
  role      ProjectRole
  tasks     Task[]      @relation("TaskAssignees")

  @@unique([projectId, userId])
}

model Phase {
  id          String    @id @default(cuid())
  name        String
  description String?
  startDate   DateTime?
  endDate     DateTime?
  project     Project   @relation(fields: [projectId], references: [id])
  projectId   String
  tasks       Task[]
  meetingLogs MeetingLog[]
  documents   Document[]
  invoices    Invoice[]
  receipts    PaymentReceipt[]
  additionalCosts AdditionalCost[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt
}

model Task {
  id          String              @id @default(cuid())
  title       String
  description String
  status      TaskStatus          @default(NOT_STARTED)
  priority    Priority            @default(MEDIUM)
  startDate   DateTime?
  dueDate     DateTime?
  phase       Phase               @relation(fields: [phaseId], references: [id])
  phaseId     String
  assignees   ProjectMembership[] @relation("TaskAssignees")
  meetingLogs MeetingLog[]
  timeLogs    TimeLog[]
  comments    Comment[]
  documents   Document[]
  history     HistoryEvent[]
  additionalCosts AdditionalCost[]
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
}

enum MeetingType {
  ONLINE
  PHYSICAL
}

model MeetingLog {
  id                String       @id @default(cuid())
  title             String
  meetingDate       DateTime
  type              MeetingType  @default(ONLINE)
  project           Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId         String
  phase             Phase?       @relation(fields: [phaseId], references: [id], onDelete: SetNull)
  phaseId           String?
  task              Task?        @relation(fields: [taskId], references: [id], onDelete: SetNull)
  taskId            String?
  clParticipantIds  String[]
  clientParticipants String?
  durationHours     Float
  clHeadcount       Int
  totalEffort       Float
  discussion        String?
  createdBy         User?        @relation("MeetingLogCreator", fields: [createdById], references: [id], onDelete: SetNull)
  createdById       String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  @@index([projectId])
  @@index([phaseId])
  @@index([taskId])
  @@index([meetingDate])
  @@index([createdById])
}

model TimeLog {
  id           String      @id @default(cuid())
  task         Task        @relation(fields: [taskId], references: [id])
  taskId       String
  user         User        @relation(fields: [userId], references: [id])
  userId       String
  startedAt    DateTime
  endedAt      DateTime
  durationMins Int
  hourlyRate   Float?
  description  String
  attachment   Attachment? @relation(fields: [attachmentId], references: [id])
  attachmentId String?     @unique
  createdAt    DateTime    @default(now())
}

model AdditionalCost {
  id             String   @id @default(cuid())
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId      String
  phase          Phase?   @relation(fields: [phaseId], references: [id], onDelete: SetNull)
  phaseId        String?
  task           Task?    @relation(fields: [taskId], references: [id], onDelete: SetNull)
  taskId         String?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  category       String
  customCategory String?
  amount         Float
  note           String?
  spentAt        DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([projectId])
  @@index([phaseId])
  @@index([taskId])
  @@index([userId])
  @@index([spentAt])
}

model Comment {
  id        String    @id @default(cuid())
  task      Task      @relation(fields: [taskId], references: [id])
  taskId    String
  author    User      @relation("CommentAuthor", fields: [authorId], references: [id])
  authorId  String
  content   String
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  parentId  String?
  replies   Comment[] @relation("CommentReplies")
  mentions  User[]    @relation("CommentMentions")
  createdAt DateTime  @default(now())
}

model Document {
  id          String   @id @default(cuid())
  // Association: project/phase required by API, task optional
  project     Project? @relation(fields: [projectId], references: [id])
  projectId   String?
  phase       Phase?   @relation(fields: [phaseId], references: [id])
  phaseId     String?
  task        Task?    @relation(fields: [taskId], references: [id])
  taskId      String?
  name        String
  externalLink String?
  reviewer    User?    @relation("DocumentReviewer", fields: [reviewerId], references: [id])
  reviewerId  String?
  filePath    String
  createdBy   User     @relation("DocumentCreator", fields: [createdById], references: [id])
  createdById String
  status      DocumentStatus @default(DRAFT)
  reviewComment String?
  reviewLink  String?
  reviewScore Int?
  reviewedAt  DateTime?
  version     Int      @default(1)
  createdAt   DateTime @default(now())

  @@index([reviewerId, status])
  @@index([projectId, phaseId])
  @@index([createdById])
}

enum DocumentStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  NEEDS_CHANGES
  REJECTED
}

model Attachment {
  id        String   @id @default(cuid())
  filePath  String
  fileType  String
  createdAt DateTime @default(now())
  project   Project? @relation(fields: [projectId], references: [id])
  projectId String?
  timeLog   TimeLog?
}

model Notification {
  id        String   @id @default(cuid())
  user      User     @relation("UserNotifications", fields: [userId], references: [id])
  userId    String
  type      NotificationType @default(COMMENT)
  title     String   @default("")
  message   String
  targetUrl String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([userId, read])
}

enum NotificationType {
  PROJECT_ASSIGNMENT
  TASK_ASSIGNMENT
  COMMENT
  TIME_LOG
  DOCUMENT_SHARED
  CALENDAR_EVENT
  INVOICE_APPROVAL
}

model HistoryEvent {
  id          String      @id @default(cuid())
  task        Task        @relation(fields: [taskId], references: [id])
  taskId      String
  type        HistoryType
  message     String
  createdBy   User        @relation("HistoryCreatedBy", fields: [createdById], references: [id])
  createdById String
  createdAt   DateTime    @default(now())
}

enum ProjectRole {
  DIRECTOR
  MANAGER
  CONSULTANT
  LEAD
  ENGINEER
  OPS
}

enum ProjectStatus {
  PLANNING
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum TaskStatus {
  NOT_STARTED
  IN_PROGRESS
  ON_HOLD
  COMPLETED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum Visibility {
  PRIVATE
  TEAM
  COMPANY
}

enum HistoryType {
  TIME_LOG
  COMMENT
  DOCUMENT
  STATUS_CHANGE
}

// Invoicing
enum InvoiceStatus {
  DRAFT
  SENT
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELED
}

enum InvoiceApprovalStatus {
  PENDING
  APPROVED
  CHANGES_REQUESTED
  REJECTED
}

model Invoice {
  id           String        @id @default(cuid())
  invoiceNo    String        @unique
  createdBy    User?         @relation("InvoiceCreatedBy", fields: [createdById], references: [id])
  createdById  String?
  approvedBy   User?         @relation("InvoiceApprovedBy", fields: [approvedById], references: [id])
  approvedById String?
  project      Project       @relation(fields: [projectId], references: [id])
  projectId    String
  phase        Phase         @relation(fields: [phaseId], references: [id])
  phaseId      String
  clientCompanyName String?
  clientAddress   String?
  clientPhone     String?
  clientName      String?
  clientDesignation String?
  issueDate    DateTime
  dueDate      DateTime
  currency     String
  subtotal     Float         @default(0)
  taxAmount    Float         @default(0)
  vatAmount    Float         @default(0)
  total        Float         @default(0)
  collected    Float         @default(0)
  outstanding  Float         @default(0)
  status       InvoiceStatus @default(DRAFT)
  approvalStatus InvoiceApprovalStatus @default(PENDING)
  approvalNote String?
  approvedAt   DateTime?
  pdfKey       String?
  notes        String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  // Back-relations
  receipts     PaymentReceipt[]
  bankCredits  BankCredit[]
  matches      PaymentMatch[]

  @@index([projectId])
  @@index([phaseId])
}

// Slips & Bank Credits persistence
enum ReceiptStatus {
  SUBMITTED
  VERIFIED
  REJECTED
}

enum BankCreditStatus {
  UNMATCHED
  MATCHED
  NEEDS_REVIEW
}

model PaymentReceipt {
  id               String         @id @default(cuid())
  paymentRequestId String?
  invoice          Invoice?       @relation(fields: [invoiceId], references: [id])
  invoiceId        String?
  project          Project?       @relation(fields: [projectId], references: [id])
  projectId        String?
  phase            Phase?         @relation(fields: [phaseId], references: [id])
  phaseId          String?
  source           String
  fileKey          String?
  fileName         String?
  fileType         String?
  fileSize         Int?
  amount           Float?
  paidDate         DateTime?
  transactionRef   String?
  payerName        String?
  payerEmail       String?
  status           ReceiptStatus  @default(SUBMITTED)
  confidence       Float?
  flags            String[]
  senderEmail      String?
  messageId        String?
  gmailThreadId    String?
  receivedAt       DateTime       @default(now())
  reviewedBy       String?
  reviewedAt       DateTime?
  reviewNote       String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  // Back-relations
  matches          PaymentMatch[]

  @@index([invoiceId])
  @@index([projectId])
  @@index([phaseId])
  @@index([receivedAt])
  @@unique([messageId, fileName])
}

model BankCredit {
  id               String           @id @default(cuid())
  amount           Float
  currency         String
  valueDate        DateTime
  payerName        String?
  bankRef          String?
  memo             String?
  sourceMailbox    String
  messageId        String          @unique
  receivedAt       DateTime
  matchedInvoice   Invoice?        @relation(fields: [matchedInvoiceId], references: [id])
  matchedInvoiceId String?
  matchedAmount    Float?
  confidence       Float?
  status           BankCreditStatus @default(UNMATCHED)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  // Back-relations
  matches          PaymentMatch[]

  @@index([matchedInvoiceId])
  @@index([receivedAt])
}

model PaymentMatch {
  id           String        @id @default(cuid())
  invoice      Invoice       @relation(fields: [invoiceId], references: [id])
  invoiceId    String
  receipt      PaymentReceipt? @relation(fields: [receiptId], references: [id])
  receiptId    String?
  bankCredit   BankCredit?   @relation(fields: [bankCreditId], references: [id])
  bankCreditId String?
  amount       Float
  matchedAt    DateTime      @default(now())
  matchedBy    String
  type         String

  @@index([invoiceId])
}
